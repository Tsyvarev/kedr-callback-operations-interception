<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>2. Overview</title><link rel="stylesheet" href="kedr-coi-doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="KEDR COI 0.1 Reference Manual"><link rel="up" href="index.html" title="KEDR COI 0.1 Reference Manual"><link rel="prev" href="intro.html" title="1. Introduction"><link rel="next" href="install.html" title="3. Installation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Overview</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="intro.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="install.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview"></a>2. Overview</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="overview.html#overview.general">2.1. General</a></span></dt><dt><span class="section"><a href="overview.html#overview.sys_req">2.2. System Requirements</a></span></dt><dt><span class="section"><a href="overview.html#overview.technologies">2.3. Key Technologies KEDR COI Relies Upon</a></span></dt><dt><span class="section"><a href="overview.html#overview.common_use_case">2.4. Common Use Case</a></span></dt><dt><span class="section"><a href="overview.html#overview.limit">2.5. Limitations</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview.general"></a>2.1. General</h3></div></div></div><p>
Linux kernel is written on C programming language, which itself not support object oriented programming(OOP). But Linux kernel widely uses many OOP principles in its implementation.
</p><p>
Impressive example is a virtual file system(VFS), which is builded from objects of different types: inodes('<span class="type">struct inode</span>'), directory entries('<span class="type">struct dentry</span>'), super blocks('<span class="type">struct super</span>'), files('<span class="type">struct file</span>') and others. These types are very similar to virtual objects in OOP sence: aside from normal functions, which work with objects of that types and which is used to implement VFS, objects of these types also have 'virtual functions', which express properties of conrecte objects and called by VFS when it need to perform 'device-dependent' operation on the object.
</p><p>
In the kernel virtual functions are implemented via <a class="firstterm" href="glossary.html#callback_operation"><em class="firstterm">callback operations</em></a>, pointer to which is stored inside object. E.g., file object('<span class="type">struct file</span>') has more then ten callback operations, such as <code class="function">open</code>, <code class="function">read</code>, <code class="function">fcntl</code>, <code class="function">poll</code>. All of them are organized into one structure('<span class="type">struct file_operations</span>'), pointer to which is stored inside a file object(field 'f_op').
</p><p>
KEDR COI library allows to intercept callback operations of the objects inside Linux kernel. Such interception may be used for simple collecting usage statistics of functions implemented these operations, or be part of more complex analisys.
</p><p>
Currently there are several tools, like SystemTap, that allow to intercept kernel functions implemented different part of system calls, like <code class="function">open</code>, <code class="function">close</code>, <code class="function">fcntl</code>... These functions call corresponded callback operations - <code class="function">open</code>, <code class="function">release</code>, <code class="function">fcntl</code>. This fact may be used for intercept callback operations with, e.g., SystemTap, but:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
There is no one-to-one correspondence between callback operations and kernel functions used to call them. Some kernel function may call several callback operations and some callback operation may be called from several kernel function.
        </li><li class="listitem">
Some callback operations are called from kernel functions in non-trivial fasion. Example - <code class="function">poll</code> operation is called inside the loop of <code class="function">select</code> kernel function.
        </li><li class="listitem">
Implementation of interception of callback operation via kernel function interception leads to interception of ALL callback operation calls, whenever it is needed or not.
        </li></ol></div><p>
</p><p>
Features of interception done by KEDR COI library:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Callback operation call is intercepted regadless what kernel function calls it and how.
        </li><li class="listitem">
Only those callback operations are intercepted which are called for objects which previously marked as 'watched'. Such marks are made dynamically, i.e. choice whether to watch an object or not is done when kernel code is executed.
        </li></ol></div><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview.sys_req"></a>2.2. System Requirements</h3></div></div></div><p>
KEDR COI library works on Linux kernel versions 2.6.31 or newer. There is no principal restrictions to work with older kernels, but building library and its working are tested only on that kernels.
</p><p>
For the present time, only x86 and x86-64 architectures are supported. Also, there is no principal restrictions to work with other architectures.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview.technologies"></a>2.3. Key Technologies KEDR COI Relies Upon</h3></div></div></div><p>
Really, different virtual objects in Linux kernel are implemented in different ways.
</p><p>
The most common way is to collect all pointers to callback operation ('virtual methods') in one structure and store pointer to concrete structure in the object structure. E.g., all callback operations for file object('<span class="type">struct file</span>') are collected in structure '<span class="type">file_operations</span>', and pointer to this structure is stored in the object's field 'f_op'. Different file objects may share same structure with operations.
</p><p>
Another way is to store pointers to different callback operations in the different object's fields. E.g., file system type object('<span class="type">struct file_system_type</span>') has two callback operations - <code class="function">mount</code> and <code class="function">kill_sb</code>(in kernels before 2.6.39 <code class="function">mount</code> is named <code class="function">get_sb</code>), pointer to each operation is stored in corresponded field of the object.
</p><p>
KEDR COI library work with both implementations of callback operations and implements interception mechanism via replacing callback operations with special ones, referred to as <a class="firstterm" href="glossary.html#intermediate_operation"><em class="firstterm">intermediate operations</em></a>. When external kernel code call some intercepted object's callback operation, it really call intermediate operation. This operation calls all registered <a class="firstterm" href="glossary.html#pre_handler"><em class="firstterm">pre-handlers</em></a>, then original object's operation and then <a class="firstterm" href="glossary.html#post_handler"><em class="firstterm">post-handlers</em></a>.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview.common_use_case"></a>2.4. Common Use Case</h3></div></div></div>
Here is a common usage of KEDR COI library for intercept callback operations of the objects:
<div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
Choose callback operations you need to intercept, and what actions you need to execute at that moment. Implement these actions as <a class="link" href="glossary.html#interception_handler">interception handlers</a> in terms of KEDR COI library.
</p></li><li class="step"><p>
Create <a class="link" href="glossary.html#interceptor">interceptor</a> for every object's type which callback operations are needed to intercept. Interceptors for some object's types are already implemented in the KEDR COI as preexisted source and header files. Code of interceptors for other object's types may be generated from user-written definition files (see <a class="xref" href="create_interceptors_using_kedr_gen.html">Section 6, “Create interceptors using template-based file generation”</a>).
</p></li><li class="step"><p>
Create <a class="link" href="glossary.html#payload">payloads</a> with pre- and post- handlers you want to call when intercept operations. Register these payloads with corresponded interceptors.
</p></li><li class="step"><p>
Call <code class="function"><a class="function" href="api_reference.html#api_reference.interceptor.start">kedr_coi_interceptor_start</a></code> for every interceptor used.
</p></li><li class="step"><p>
Determine moments when objects which operations you want to intercept are created(or became available for using). Call <code class="function"><a class="function" href="api_reference.html#api_reference.interceptor.watch">kedr_coi_interceptor_watch</a></code> at that moments. Depended from objects type, this function may be called from interception handlers for kernel global functions, from interception handlers of another callback operations or may be called automatically when use <a class="link" href="glossary.html#foreign_interceptor">foreign interceptor</a>. See <a class="xref" href="using_kedr_coi.html#objects_watching.when_to_watch">Section 4.3.1, “When call of <code class="function">kedr_coi_interceptor_watch</code> should be made”</a> for more details.
</p><p>
Note, that calling of <code class="function"><a class="function" href="api_reference.html#api_reference.interceptor.watch">kedr_coi_interceptor_watch</a></code> from interceptor handlers of another callback operations may introduce new interception handlers and new callback operations intercepted, so all previous steps should be revisited.
</p></li><li class="step"><p>
Determine moments when objects which operations you want to intercept are destroyed(or became unavailable for using). Call <code class="function"><a class="function" href="api_reference.html#api_reference.interceptor.forget">kedr_coi_interceptor_forget</a></code> or <code class="function">kedr_coi_interceptor_forget_unrestore</code> at that moments. Depended from objects type, this function may be called from interception handlers for kernel global functions or from interception handlers of another callback operations. See <a class="xref" href="using_kedr_coi.html#objects_watching.when_to_forget">Section 4.3.3, “When <code class="function">kedr_coi_interceptor_forget</code> should be called”</a> for more details.
</p><p>
Note, that calling of <code class="function"><a class="function" href="api_reference.html#api_reference.interceptor.forget">kedr_coi_interceptor_forget</a></code> from interceptor handlers of another callback operations may introduce new interception handlers and new callback operations intercepted, so all previous steps should be revisited.
</p></li><li class="step"><p>
After interception mechanism become not needed, call <code class="function"><a class="function" href="api_reference.html#api_reference.interceptor.stop">kedr_coi_interceptor_stop</a></code> for every interceptor used.
</p></li><li class="step"><p>
Unregister all payloads and destroy all created interceptors.
</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="overview.limit"></a>2.5. Limitations</h3></div></div></div><div class="itemizedlist"><p>
The ideas KEDR COI is based upon impose some limitations on what it can be used for.
</p><ul class="itemizedlist" type="disc"><li class="listitem"><p>
KEDR COI need to modify object for its operations became interceptable. So, you need to intercept creation(or some later) moment for every object which operations you want to intercept. If you unable to do this, the library cannot be applied.
    </p></li><li class="listitem"><p>
Modification of the object, done by the library, may conflict with modification of the object, done by external code. In the first queue it concerned changing of the object's field pointed to operation(s). If external code change operation(s) of the object is watched, interception mechanism does not work for that object until kedr_coi_interceptor_watch() will be called for object again.
    </p><p>
 In the current implementation of the library, watching an object doesn't change pointer to its operation structure. So, if external code set pointer to callback operations of the object to one which has been before object is watched (this is the most frequent case when external code set pointer to operations), interception mechanism doesn't break.
    </p></li><li class="listitem"><p>
Objects which share same operations struct cannot be watched by different interceptors, so cannot have different set of payloads with interception handlers. This is a price for interception mechanism tolerance to setting pointer to operation(s) by external code.
    </p><p>
In any case, different interceptors cannot watch the same object.
    </p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="intro.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="install.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1. Introduction </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3. Installation</td></tr></table></div></body></html>
