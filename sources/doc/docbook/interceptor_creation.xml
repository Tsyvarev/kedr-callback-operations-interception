<section id="interceptor_creation">
<title>Creation of the interceptors</title>
<para>
Interceptors for different object types has a deal in common. All common things are combined into '<type>struct kedr_coi_interceptor</type>', which is something like a virtual object. Concrete instances of this object are created using <function>kedr_coi_interceptor_create</function> or <function>kedr_coi_interceptor_create_direct</function>. Two type of information should be passed to any of these functions for create interceptor: object's geometry and array of <firstterm linkend="intermediate_operation">intermediate operations</firstterm>.
</para>

<section id="interceptor_creation.object_geometry">
<title>Object's geometry</title>
<para>
There are two types of the interceptors, which differs in the implementation of callback operations in the object. This difference in callback operations implementation affects on what function should be used for create interceptor.
</para>

<section id="interceptor_creation.object_geometry.direct">
<title>Direct interceptor</title>
<para>
One type of the interceptor is a 'direct'. It is suitable for objects which contain pointers to callback operations as fields. One field correspond to one callback operation.
</para>
<para>
Interceptor for objects of that type is created using <function>kedr_coi_interceptor_create_direct</function>, and size of objects structure is used as object's geometry information. Each callback operation for that objects is identified with offset of pointer to that operation inside object structure.
</para>
</section>
<!-- End of "interceptor_creation.object_geometry.direct" -->

<section id="interceptor_creation.object_geometry.indirect">
<title>Indirect interceptor</title>
<para>
Another type of interceptor is an 'indirect'. It is suitable for objects which operations are organized into one structure, distinct from the objects type. Objects itself contain one field which points to concrete structure of operations.
</para>
<para>
Interceptor for objects of that type is created using <function>kedr_coi_interceptor_create</function>, object's geometry information contain size of operations structure and offset of the field pointed to the operations inside objects structure. Each callback operation for that objects is identified with offset of pointer to that operation inside operations structure.
</para>

</section>
<!-- End of "interceptor_creation.object_geometry.indirect" -->

</section>
<!-- End of "interceptor_creation.object_geometry" -->

<section id="interceptor_creation.intermediate_operations">
<title>Intermediate operations</title>
<para>
KEDR COI interception mechanism  is based on replacing object's callback operations with another operations, referred to as <firstterm linkend="intermediate_operation">intermediate</firstterm>. These intermediate operations are responsible for call registered pre-handlers, post-handlers and object's original operation in correct order. There are several reasons, why these operations cannot be automatically generated by the library itself(see <xref linkend="interceptor_creation.intermediate_operations.why_not_generated"/>), so them should be written by hand.
</para>
<para>
Only those callback operations may be intercepted for which intermediate operation is exist. Attempt to register payload which require to intercept other operation will result in error.
</para>
<para>
Really, intermediate operations should implements simple logic. Moreover, code of the intermediate operations may be generated from a few data about them(see <xref linkend="create_interceptors_using_kedr_gen"/>). Intermediate operation should have same signature as original callback operation and should implement following logic:
</para>

<procedure>
<step><para>
Locally allocate(e.g., on the stack) object of type '<type>struct kedr_coi_intermediate_info</type>'.
</para></step>
<step><para>
Call 'kedr_coi_get_intermediate_info', passing to it interceptor, owner object of this operation, offset of the corresponded callback operation(see <xref linkend="interceptor_creation.object_geometry"/>) and info object allocated on the previous step. This call fills the info object.
</para></step>
<step><para>
If array of pre-handlers(contained in the filled info object) is not empty, all pre-handlers from it should be called in order. All arguments of the intermediate operation should be passed to each handler as first arguments. Pointer to locally allocated and filled object of type '<type>struct kedr_coi_operation_call_info</type>' should be passed as the last argument.
</para></step>
<step><para>
Original operation(pointer to which is contained in the filled info object) should be called with arguments of intermediate operation. If pointer to original operation is NULL, code of the <firstterm linkend="default_callback_operation">default operation</firstterm> should be executed instead.
</para></step>
<step><para>
If array of post-handlers(contained in the filled info object) is not empty, all post-handlers from it should be called in order. All arguments of the intermediate operation should be passed to each handler as first arguments. If call of original operation has returned any value, this value should be passed to each handler after all intermediate operations arguments. Pointer to locally allocated and filled object of type '<type>struct kedr_coi_operation_call_info</type>' should be passed as the last argument.
</para></step>
<step><para>
If original operation return any value, this value should be returned by the intermediate operation.
</para></step>
</procedure>

<para>
Let object 'foo' be declared in that way:
<programlisting><![CDATA[
struct foo_operations;
struct foo
{
    int some_field;
    const struct foo_operations* foo_ops;
    void* some_other_fields;
};
struct foo_operations
{
    int (*do_smth)(struct foo* obj, long some_arg);
    void (*do_another)(struct foo* obj, int a, void* b);
};
]]></programlisting>
There is an example of intermediate operation for callback operation 'do_smth' of the object:
<programlisting><![CDATA[
struct kedr_coi_interceptor* interceptor;
//...
int intermediate_do_smth(struct foo* obj, long some_arg)
{
    struct kedr_coi_intermediate_info info;
    struct kedr_coi_operation_call_info call_info;
    int (*op_orig)(struct foo* obj, long some_arg);
    int result;
    
    kedr_coi_get_intermediate_info(interceptor,
        obj,
        offsetof(do_smth, struct foo_operations),
        &info);
    
    call_info.return_address = __builting_return_address(0);
    call_info.op_orig = info.op_orig;
    
    if(info.pre)
    {
        void (**pre)(struct foo*, long, struct kedr_coi_operation_call_info*);
        for(pre = (typeof(pre))info.pre; *pre != NULL; pre++)
            (*pre)(obj, some_arg, &call_info);
    }
    
    op_orig = (typeof(op_orig))info.op_orig;
    result = op_orig ? op_orig(obj, some_arg) : 0;
    
    if(info.post)
    {
        void (**post)(struct foo*, long, int, struct kedr_coi_operation_call_info*);
        for(post = (typeof(post))info.post; *post != NULL; post++)
            (*post)(object, some_arg, result, &call_info);
    }
    
    return result;
}
]]></programlisting>
Note that here we process case when original callback operation of the object is NULL. We assume that this case has same effect as callback operation simply returning 0.
</para>

<section id="interceptor_creation.intermediate_operations.grouping">
<title>Grouping of intermediate operations</title>
<para>
A callback operation may be intercepted only if there is an intermediate operation for it, and if callback operation is intercepted(some registered payload contains interception handler for it), corresponded intermediate operation will be called instead of original callback operation. But if a callback operation interception isn't need, intermediate operation for it isn't used.
</para>
<para>
Usually such approach is useful, but there is a case when intermediate operation needs to be used whenever its corresponded callback operation needs to be intercepted. This is a situation when default operation for some callback operation may not be implemented exactly for some reasons(e.g., some variable or function definition is not available for module which implements intermediate operation).
</para>
<para>
For example, default <function>alloc_inode</function> callback operation of super block should allocate memory for inode from the internal memory cache which is not accessible from kernel modules. According to the specification of <function>alloc_inode</function> callback operation, it may allocate inode in any memory space. One may use this specification and implement <function>alloc_inode</function> intermediate operation, e.g., via kmalloc. But default implementation of another callback operation, <function>destroy_inode</function>, free exactly internal memory cache, which will lead to fault if the inode is allocated in another memory space.
</para>
<para>
Decision of the problem with <function>alloc_inode</function> default callback operation may be:
<itemizedlist>
    <listitem>
Implement default operation of <function>alloc_inode</function> in intermediate operation via kmalloc.
    </listitem>
    <listitem>
Implement default operation of <function>destroy_inode</function> in intermediate operation via kfree.
    </listitem>
    <listitem>
Enforce intermediate operations for <function>alloc_inode</function> and <function>destroy_inode</function> to be used with each other.
    </listitem>
</itemizedlist>

</para>

<para>
Last point may be implemented setting 'group_id' fields of intermediate operation structures('<type>struct kedr_coi_intermediate</type>') for <function>alloc_inode</function> and <function>destroy_inode</function> to the same non-zero interger.

<programlisting><![CDATA[
//...
struct inode* intermediate_alloc_inode(struct super_block* sb)
{
    struct inode* result;
    //...
    if(op_orig)
    {
        inode = op_orig(sb);
    }
    else
    {
        inode = kmalloc(sizeof(*inode), GFP_KERNEL);
        if(inode) inode_init_once(inode);
    }
    //...
    
    return inode;
}

void intermediate_destroy_inode(struct inode* inode)
{
    //...
    op_orig ? op_orig(inode) : kfree(inode);
    //...
}

struct kedr_coi_intermediate super_block_intermediates =
{
    {
        .operation_offset = offsetof(struct super_block, alloc_inode),
        .repl = (void*)&intermediate_alloc_inode,
        .group_id = 1 // may be any non-zero
    },
    {
        .operation_offset = offsetof(struct super_block, destroy_inode),
        .repl = (void*)&intermediate_destroy_inode,
        .group_id = 1 //should be same as for alloc_inode intermediate
    },
    //.. Other intermediate operations
};

]]></programlisting>
</para>


</section>
<!-- End of "interceptor_creation.intermediate_operations.grouping" -->

<section id="interceptor_creation.intermediate_operations.why_not_generated">
<title>Reasons why intermediate operations is not generated automatically by the library</title>
<para>
It would be better if intermediate operations are generated internally by the library. But there are two barries to make this effectively.
</para>
<para>
The first problem - different callback operations accept different number of arguments and that arguments has different types. Because these arguments should be passed to the interception handlers, which signature is differ from callback operation's one, intermediate operation should be aware of signature of original one.
</para>
<para>
The second problem - while in the common OOP implementations virtual method accept object, on which this method is affects, as first argument, implementation of callback operations in the Linux kernel doesn't follow this principle everywhere. Some callback operations accept affected object as non-first argument (<function>open</function> operation of the file object), others should extract affected object not from an argument but from the field of some argument (<function>kill_sb</function> operation of file_system_type object).
</para>
<para>
Both these problems make fully automated generation of intermediate operations impossible. Runtime generation of the code of such operations based on some parameters is possible, but may be implemented only in machine codes, which is difficult and badly affects on cross-platform portability.
</para>
</section>
<!-- End of "interceptor_creation.intermediate_operations.why_not_generated" -->

</section>
<!-- End of "interceptor_creation.intermediate_operations" -->

</section>
<!-- End of "interceptor_creation" -->