<section id="interceptor_creation">
<title>Creation of the interceptors</title>
<para>
Interceptors for different object types has a deal in common. All common things are combined into '<type>struct kedr_coi_interceptor</type>', which is something like a virtual object. Concrete instances of this object are created using <function linkend="api_reference.interceptor_creation.indirect">kedr_coi_interceptor_create</function> or <function linkend="api_reference.interceptor_creation.direct">kedr_coi_interceptor_create_direct</function>. Two type of information should be passed to any of these functions for create interceptor: object's geometry and array of <firstterm linkend="intermediate_operation">intermediate operations</firstterm>.
</para>

<section id="interceptor_creation.object_geometry">
<title>Object's geometry</title>
<para>
There are two types of the interceptors, which differs in the implementation of callback operations in the object. This difference in callback operations implementation affects on what function should be used for create interceptor.
</para>

<section id="interceptor_creation.object_geometry.direct">
<title>Direct interceptor</title>
<para>
One type of the interceptor is a 'direct'. It is suitable for objects which contain pointers to callback operations as fields. One field correspond to one callback operation.
</para>
<para>
Interceptor for objects of that type is created using <function linkend="api_reference.interceptor_creation.direct">kedr_coi_interceptor_create_direct</function>, and size of objects structure is used as object's geometry information. Each callback operation for that objects is identified with offset of pointer to that operation inside object structure.
</para>
</section>
<!-- End of "interceptor_creation.object_geometry.direct" -->

<section id="interceptor_creation.object_geometry.indirect">
<title>Indirect interceptor</title>
<para>
Another type of interceptor is an 'indirect'. It is suitable for objects which operations are organized into one structure, distinct from the objects type. Objects itself contain one field which points to concrete structure of operations.
</para>
<para>
Interceptor for objects of that type is created using <function linkend="api_reference.interceptor_creation.indirect">kedr_coi_interceptor_create</function>, object's geometry information contain size of operations structure and offset of the field pointed to the operations inside objects structure. Each callback operation for that objects is identified with offset of pointer to that operation inside operations structure.
</para>

</section>
<!-- End of "interceptor_creation.object_geometry.indirect" -->

</section>
<!-- End of "interceptor_creation.object_geometry" -->

<section id="interceptor_creation.intermediate_operations">
<title>Intermediate operations</title>
<para>
KEDR COI interception mechanism  is based on replacing object's callback operations with another operations, referred to as <firstterm linkend="intermediate_operation">intermediate</firstterm>. These intermediate operations are responsible for call registered pre-handlers, post-handlers and object's original operation in correct order. There are several reasons, why these operations cannot be automatically generated by the library itself(see <xref linkend="interceptor_creation.intermediate_operations.why_not_generated"/>), so them should be written by hand.
</para>
<para>
Only those callback operations may be intercepted for which intermediate operations exist. Attempt to register payload which require to intercept other operation will result in error.
</para>
<para>
Really, intermediate operations should implement simple logic. Moreover, code of the intermediate operations may be generated from a few data about them(see <xref linkend="create_interceptors_using_kedr_gen"/>). Intermediate operation should have same signature as original callback operation and should implement following logic:
</para>

<procedure>
<step><para>
Locally allocate(e.g., on the stack) object of type '<type linkend="api_reference.struct_intermediate_info">struct kedr_coi_intermediate_info</type>'.
</para></step>
<step><para>
Call <function linkend="api_reference.interceptor_creation.get_intermediate_info">kedr_coi_get_intermediate_info</function>, passing to it interceptor, owner object of this operation, offset of the corresponded callback operation(see <xref linkend="interceptor_creation.object_geometry"/>) and info object allocated on the previous step. This call fills the info object.
</para></step>
<step><para>
If array of pre-handlers(contained in the filled info object) is not empty, all pre-handlers from it should be called in order. All arguments of the intermediate operation should be passed to each handler as first arguments. Pointer to locally allocated and filled object of type '<type linkend="api_reference.struct_operation_call_info">struct kedr_coi_operation_call_info</type>' should be passed as the last argument.
</para></step>
<step><para>
Original operation(pointer to which is contained in the filled info object) should be called with arguments of intermediate operation. If pointer to original operation is NULL, code of the <firstterm linkend="default_callback_operation">default operation</firstterm> should be executed instead. Note that if intermediate operation is 'internal_only' (see <xref linkend="interceptor_creation.intermediate_operations.internal_only"/>), pointer to original operation will never be NULL.
</para></step>
<step><para>
If array of post-handlers(contained in the filled info object) is not empty, all post-handlers from it should be called in order. All arguments of the intermediate operation should be passed to each handler as first arguments. If call of original operation has returned any value, this value should be passed to each handler after all intermediate operations arguments. Pointer to locally allocated and filled object of type '<type linkend="api_reference.struct_operation_call_info">struct kedr_coi_operation_call_info</type>' should be passed as the last argument.
</para></step>
<step><para>
If original operation return any value, this value should be returned by the intermediate operation.
</para></step>
</procedure>

<para>
Let object 'foo' be declared in that way:
<programlisting><![CDATA[
struct foo_operations;
struct foo
{
    int some_field;
    const struct foo_operations* foo_ops;
    void* some_other_fields;
};
struct foo_operations
{
    int (*do_smth)(struct foo* obj, long some_arg);
    void (*do_another)(struct foo* obj, int a, void* b);
};
]]></programlisting>
There is an example of intermediate operation for callback operation 'do_smth' of the object:
<programlisting><![CDATA[
struct kedr_coi_interceptor* interceptor;
//...
int intermediate_do_smth(struct foo* obj, long some_arg)
{
    struct kedr_coi_intermediate_info info;
    struct kedr_coi_operation_call_info call_info;
    int (*op_orig)(struct foo* obj, long some_arg);
    int result;
    
    kedr_coi_get_intermediate_info(interceptor,
        obj,
        offsetof(do_smth, struct foo_operations),
        &info);
    
    call_info.return_address = __builting_return_address(0);
    call_info.op_orig = info.op_orig;
    
    if(info.pre)
    {
        void (**pre)(struct foo*, long, struct kedr_coi_operation_call_info*);
        for(pre = (typeof(pre))info.pre; *pre != NULL; pre++)
            (*pre)(obj, some_arg, &call_info);
    }
    
    op_orig = (typeof(op_orig))info.op_orig;
    result = op_orig ? op_orig(obj, some_arg) : 0;
    
    if(info.post)
    {
        void (**post)(struct foo*, long, int, struct kedr_coi_operation_call_info*);
        for(post = (typeof(post))info.post; *post != NULL; post++)
            (*post)(object, some_arg, result, &call_info);
    }
    
    return result;
}
]]></programlisting>
Note that here we process case when original callback operation of the object is NULL. We assume that this case has same effect as callback operation simply returning 0.
</para>

<section id="interceptor_creation.intermediate_operations.internal_only">
<title>Intermediate operations only for internal interception</title>
<para>
By default, callback operation may be intercepted even when pointer to it is NULL. This is achieved by setting 'external' flag of interception handler to true. In that case NULL pointer is replaced with pointer to intermediate operation, which should execute code of some <firstterm linkend="default_callback_operation">default callback operation</firstterm>.
</para>
<para>
But for some callback operations their default variant may be difficult to be implemented in the module. E.g. default <function>d_dname</function> callback for <type>dentry</type> object should use different locks which are accessible only for kernel core.
</para>
<para>
Other callback operations has no default variant at all - non-NULL callback operation endows object with properties differs from ones in case of NULL-pointer. E.g. non-NULL pointer to <function>truncate_range</function> callback operation of inode object tells that this inode supports range truncation. And any non-NULL implementation of that callback cannot emulate same behaviour for the kernel. Another example: non-NULL pointer to the callback operation <function>d_revalidate</function> is indicated by <constant>DCACHE_OP_REVALIDATE</constant> flag of dentry object. Without setting this flag replacing NULL-pointer to the callback operation with intermediate one has no effect.
</para>
<para>
For any intermediate there is a way to tell that interception for given callback operation shouldn't be used if pointer to it is <constant>NULL</constant>. This is achieved by setting flag 'internal_only' of the intermediate to true (see <xref linkend="api_reference.interceptor_creation.struct_intermediate"/>). Note, that 'internal_only' flag also prevents any external interception handler to be registered for this callback operation (see <xref linkend="payload_description.internal_and_external"/>).
</para>
</section> <!-- End of "interceptor_creation.intermediate_operations.internal_only" -->

<section id="interceptor_creation.intermediate_operations.grouping">
<title>Grouping of intermediate operations</title>
<para>
In some cases there is a way to intercept NULL-pointer to callback operation even when its default implementation is not accessible for module. Consider <function>alloc_inode</function>and <function>destroy_inode</function> callback functions for super block. First function should allocate memory for inode object, second one should free this memory. In-kernel default implementation of these callbacks (see <function>alloc_inode</function> and <function>destroy_inode</function> global functions implementation) uses memory cache, which is inaccessible for modules.
</para>
<para>
However, internal cache usage is not strictly required from these functions. It is required only the consistency between them - <function>destroy_inode</function> should be applicable to the pointer returned by <function>alloc_inode</function>. So one may use, for example, common <function>kmalloc</function> and <function>kfree</function> functions for implementations of the default callback operations. Such implementations work fine until be messed with in-kernel ones - attempt to apply <function>kmem_cache_free</function> with internal memory cache to the result of kmalloc will crach the kernel.
</para>
<para>
The problem is that every intermediate function is used only when interception of corresponded callback operation is requested by some payload. So, interceptor user may require interception of <function>destroy_inode</function> but do not use interception of <function>alloc_inode</function>. In that case NULL-pointer to <function>destroy_inode</function> callback operation will be replaced with intermediate operation, but NULL-pointer to <function>alloc_inode</function> will be remained unchanged.
</para>
<para>
There is a way to tell interceptor that intermediates for <function>alloc_inode</function> and <function>destroy_inode</function> should be used in pair - either both or none. It is achieved by assigning same non-zero identificator to 'group_id' fields of this intermediates.
This make intermediate <function>alloc_inode</function> to be used even without interception needs. 

<programlisting><![CDATA[
//...
struct inode* intermediate_alloc_inode(struct super_block* sb)
{
    struct inode* result;
    //...
    if(op_orig)
    {
        inode = op_orig(sb);
    }
    else
    {
        inode = kmalloc(sizeof(*inode), GFP_KERNEL);
        if(inode) inode_init_once(inode);
    }
    //...
    
    return inode;
}

void intermediate_destroy_inode(struct inode* inode)
{
    //...
    op_orig ? op_orig(inode) : kfree(inode);
    //...
}

struct kedr_coi_intermediate super_block_intermediates =
{
    {
        .operation_offset = offsetof(struct super_block, alloc_inode),
        .repl = (void*)&intermediate_alloc_inode,
        .group_id = 1 // may be any non-zero value
    },
    {
        .operation_offset = offsetof(struct super_block, destroy_inode),
        .repl = (void*)&intermediate_destroy_inode,
        .group_id = 1 //should be same as for alloc_inode intermediate
    },
    //.. Other intermediate operations
};

]]></programlisting>
</para>
<para>
See <xref linkend="api_reference.interceptor_creation.struct_intermediate"/> for formal description of 'group_id' field.
</para>

</section>
<!-- End of "interceptor_creation.intermediate_operations.grouping" -->

<section id="interceptor_creation.intermediate_operations.why_not_generated">
<title>Reasons why intermediate operations are not generated automatically by the library</title>
<para>
It would be better if intermediate operations are generated internally by the library. But there are two barries to make this effectively.
</para>
<para>
The first problem - different callback operations accept different number of arguments and that arguments has different types. Because these arguments should be passed to the interception handlers, which signature is differ from callback operation's one, intermediate operation should be aware of signature of original one.
</para>
<para>
The second problem - while in the common OOP implementations virtual method accept object, on which this method is affects, as first argument, implementation of callback operations in the Linux kernel doesn't follow this principle everywhere. Some callback operations accept affected object as non-first argument (<function>open</function> operation of the file object), others should extract affected object not from an argument but from the field of some argument (<function>kill_sb</function> operation of file_system_type object).
</para>
<para>
Both these problems make fully automated generation of intermediate operations impossible. Runtime generation of the code of such operations based on some parameters is possible, but may be implemented only in machine codes, which is difficult and badly affects on cross-platform portability.
</para>
</section>
<!-- End of "interceptor_creation.intermediate_operations.why_not_generated" -->

</section>
<!-- End of "interceptor_creation.intermediate_operations" -->

</section>
<!-- End of "interceptor_creation" -->