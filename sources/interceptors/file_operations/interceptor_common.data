interceptor.name = file_operations_interceptor
interceptor.operations_prefix = file_operations

header =>>
/* ========================================================================
 * Copyright (C) 2011, Andrey V. Tsyvarev  <tsyvarev@ispras.ru>
 *
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ======================================================================== */


#include <linux/fs.h>
<<

implementation_header =>>
#include <linux/aio.h>

#include <linux/poll.h>

#include <linux/sched.h>
#include <linux/mm_types.h>
<<

object.type = struct file
object.operations_field = f_op

operations.type = struct file_operations


[group]
operation.name = llseek
operation.returnType = loff_t

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = loff_t
operation.arg.name = offset

operation.arg.type = int
operation.arg.name = whence

operation.object = filp

operation.default = return default_llseek(filp, offset, whence);

[group]
operation.name = read
operation.returnType = ssize_t

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = char __user *
operation.arg.name = buf

operation.arg.type = size_t
operation.arg.name = count

operation.arg.type = loff_t *
operation.arg.name = f_pos

operation.object = filp

operation.default = return -EIO;

[group]
operation.name = write
operation.returnType = ssize_t

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = const char __user *
operation.arg.name = buf

operation.arg.type = size_t
operation.arg.name = count

operation.arg.type = loff_t *
operation.arg.name = f_pos

operation.object = filp

operation.default = return -EIO;

[group]
operation.name = aio_read
operation.returnType = ssize_t

operation.arg.type = struct kiocb *
operation.arg.name = iocb

operation.arg.type = const struct iovec*
operation.arg.name = iov

operation.arg.type = unsigned long
operation.arg.name = nr_segs

operation.arg.type = loff_t
operation.arg.name = pos

operation.object = iocb->ki_filp

operation.default = return generic_file_aio_read(iocb, iov, nr_segs, pos);


[group]
operation.name = aio_write
operation.returnType = ssize_t

operation.arg.type = struct kiocb *
operation.arg.name = iocb

operation.arg.type = const struct iovec*
operation.arg.name = iov

operation.arg.type = unsigned long
operation.arg.name = nr_segs

operation.arg.type = loff_t
operation.arg.name = pos

operation.object = iocb->ki_filp

operation.default = return generic_file_aio_write(iocb, iov, nr_segs, pos);


[group]
operation.name = readdir
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = void *
operation.arg.name = buf

operation.arg.type = filldir_t
operation.arg.name = filler

operation.object = filp

operation.default = return -ENOTDIR;


[group]
operation.name = poll
operation.returnType = unsigned int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = struct poll_table_struct *
operation.arg.name = wait


operation.object = filp

operation.default = return DEFAULT_POLLMASK;


[group]
operation.name = unlocked_ioctl
operation.returnType = long

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = unsigned int
operation.arg.name = cmd

operation.arg.type = unsigned long
operation.arg.name = arg

operation.object = filp

operation.default = return -ENOTTY;


[group]
operation.name = compat_ioctl
operation.returnType = long

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = unsigned int
operation.arg.name = cmd

operation.arg.type = unsigned long
operation.arg.name = arg

operation.object = filp

operation.default = return -ENOIOCTLCMD;


[group]
operation.name = mmap
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = struct vm_area_struct *
operation.arg.name = vma

operation.object = filp

operation.default = return -ENODEV;

[group]
operation.name = open
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = inode

operation.arg.type = struct file *
operation.arg.name = filp

operation.object = filp

operation.default = return 0;

[group]
operation.name = flush
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = fl_owner_t
operation.arg.name = id

operation.object = filp

operation.default = return 0;

[group]
operation.name = release
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = inode

operation.arg.type = struct file *
operation.arg.name = filp

operation.object = filp

operation.default = return 0;

[group]
operation.name = fsync
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = int
operation.arg.name = datasync

operation.object = filp

operation.default = return -EINVAL;

[group]
operation.name = aio_fsync
operation.returnType = int

operation.arg.type = struct kiocb *
operation.arg.name = iocb

operation.arg.type = int
operation.arg.name = datasync

operation.object = iocb->ki_filp

operation.default = return -EINVAL;

[group]
operation.name = fasync
operation.returnType = int

operation.arg.type = int
operation.arg.name = fd

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = int
operation.arg.name = mode

operation.object = filp

operation.default = return 0;

[group]
operation.name = lock
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = int
operation.arg.name = cmd

operation.arg.type = struct file_lock *
operation.arg.name = fl

operation.object = filp

operation.default = return posix_lock_file(filp, fl, NULL);

[group]
operation.name = sendpage
operation.returnType = ssize_t

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = struct page *
operation.arg.name = page

operation.arg.type = int
operation.arg.name = offset

operation.arg.type = size_t
operation.arg.name = size

operation.arg.type = loff_t *
operation.arg.name = ppos

operation.arg.type = int
operation.arg.name = more

operation.object = filp

operation.default = return -EINVAL;

[group]
operation.name = get_unmapped_area
operation.returnType = unsigned long

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = unsigned long
operation.arg.name = addr

operation.arg.type = unsigned long
operation.arg.name = len

operation.arg.type = unsigned long
operation.arg.name = pgoff

operation.arg.type = unsigned long
operation.arg.name = flags

operation.object = filp

operation.default = return current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);

# check_flags() operation has no affected object,
# so it cannot be intercepted using KEDR COI.

[group]
operation.name = flock
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = int
operation.arg.name = flags

operation.arg.type = struct file_lock *
operation.arg.name = fl

operation.object = filp

operation.default = return flock_lock_file_wait(filp, fl);


[group]
operation.name = splice_write
operation.returnType = ssize_t

operation.arg.type = struct pipe_inode_info *
operation.arg.name = pipe

operation.arg.type = struct file *
operation.arg.name = out

operation.arg.type = loff_t *
operation.arg.name = ppos

operation.arg.type = size_t
operation.arg.name = len

operation.arg.type = unsigned int
operation.arg.name = flags

operation.object = out

operation.default = return generic_splice_sendpage(pipe, out, ppos, len, flags);

[group]
operation.name = splice_read
operation.returnType = ssize_t

operation.arg.type = struct file *
operation.arg.name = in

operation.arg.type = loff_t *
operation.arg.name = ppos

operation.arg.type = struct pipe_inode_info *
operation.arg.name = pipe

operation.arg.type = size_t
operation.arg.name = len

operation.arg.type = unsigned int
operation.arg.name = flags

operation.object = in

operation.default = return default_file_splice_read(in, ppos, pipe, len, flags);

[group]
operation.name = setlease
operation.returnType = int

operation.arg.type = struct file *
operation.arg.name = filp

operation.arg.type = long
operation.arg.name = arg

operation.arg.type = struct file_lock **
operation.arg.name = lease

operation.object = filp

operation.default = return generic_setlease(filp, arg, lease);

