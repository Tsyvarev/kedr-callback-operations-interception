interceptor.name = inode_operations_interceptor
interceptor.operations_prefix = inode_operations

header =>>
/* ========================================================================
 * Copyright (C) 2011, Andrey V. Tsyvarev  <tsyvarev@ispras.ru>
 *
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ======================================================================== */


#include <linux/fs.h>
<<

object.type = struct inode
object.operations_field = i_op

operations.type = struct inode_operations

[group]
operation.name = create
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = int
operation.arg.name = mode

operation.arg.type = struct nameidata *
operation.arg.name = nd

operation.object = dir

# Called by vfs_create
operation.default = return -EACCES;

[group]
operation.name = lookup
operation.returnType = struct dentry *

operation.arg.type = struct inode *
operation.arg.name = inode

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = struct nameidata *
operation.arg.name = nd

operation.object = inode

# Called by __link_path_walk
operation.default = return ERR_PTR(-ENOTDIR);

[group]
operation.name = link
operation.returnType = int

operation.arg.type = struct dentry *
operation.arg.name = old_dentry

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = new_dentry

operation.object = dir

# Called by vfs_link
operation.default = return -EPERM;


[group]
operation.name = unlink
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.object = dir

# Called by
operation.default = return -EPERM;


[group]
operation.name = symlink
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = const char *
operation.arg.name = oldname

operation.object = dir

# Called by vfs_symlink
operation.default = return -EPERM;


[group]
operation.name = mkdir
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = int
operation.arg.name = mode

operation.object = dir

# Called by vfs_mkdir
operation.default = return -EPERM;


[group]
operation.name = rmdir
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.object = dir

# Called by vfs_rmdir
operation.default = return -EPERM;


[group]
operation.name = mknod
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = dir

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = int
operation.arg.name = mode

operation.arg.type = dev_t
operation.arg.name = dev

operation.object = dir

# Called vfs_mknod
operation.default = return -EPERM;


[group]
operation.name = rename
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = old_dir

operation.arg.type = struct dentry *
operation.arg.name = old_dentry

operation.arg.type = struct inode *
operation.arg.name = new_dir

operation.arg.type = struct dentry *
operation.arg.name = new_dentry

operation.object = old_dentry

# Called by vfs_rename
operation.default = return -EPERM;


[group]
operation.name = readlink
operation.returnType = int

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = char __user *
operation.arg.name = buffer

operation.arg.type = int
operation.arg.name = buflen

operation.object = dentry->d_inode

## Called by SYSCALL readlinkat
operation.default = return -EINVAL;


[group]
operation.name = follow_link
operation.returnType = void*

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = struct nameidata *
operation.arg.name = nd

operation.object = dentry->d_inode
# Called unconditionally from __do_follow_link and other places.

# It seems, that indicator of operation's existing(pointer is not NULL)
# is inode mode instead of pointer itself.

[group]
operation.name = put_link

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = struct nameidata *
operation.arg.name = nd

operation.arg.type = void *
operation.arg.name = cookie

operation.object = dentry->d_inode

# Called from put_link
operation.default = return;

[group]
operation.name = truncate

operation.arg.type = struct inode *
operation.arg.name = inode

operation.object = inode

# Called from vmtruncate
operation.default = return;


[group]
operation.name = truncate_range

operation.arg.type = struct inode *
operation.arg.name = inode

operation.arg.type = loff_t
operation.arg.name = offset

operation.arg.type = loff_t
operation.arg.name = end

operation.object = inode
# Called from vmtruncate_range, shouldn't replace NULL pointer at all.

[group]
operation.name = setattr
operation.returnType = int

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = struct iattr *
operation.arg.name = attr

operation.object = dentry->d_inode

# Called from notify_change
# Default implementation is system-depended and not easy.

[group]
operation.name = getattr
operation.returnType = int

operation.arg.type = struct vfsmount *
operation.arg.name = mnt

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = struct kstat *
operation.arg.name = stat

operation.object = dentry->d_inode

# Called from vfs_getattr
operation.default =>>
    generic_fillattr(dentry->d_inode, stat);
    return 0;
<<

[group]
operation.name = setxattr
operation.returnType = int

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = const char *
operation.arg.name = name

operation.arg.type = const void *
operation.arg.name = value

operation.arg.type = size_t
operation.arg.name = size

operation.arg.type = int
operation.arg.name = flags

operation.object = dentry->d_inode

# Called by __vfs_setxattr_noperm
# Default implementation is very kernel-depended and subtle.

[group]
operation.name = getxattr
operation.returnType = ssize_t

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = const char *
operation.arg.name = name

operation.arg.type = void *
operation.arg.name = value

operation.arg.type = size_t
operation.arg.name = size

operation.object = dentry->d_inode

# Called by vfs_getxattr
operation.default = return -EOPNOTSUPP;

[group]
operation.name = listxattr
operation.returnType = ssize_t

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = char *
operation.arg.name = list

operation.arg.type = size_t
operation.arg.name = size

operation.object = dentry->d_inode

# Called by vfs_listxattr
# Default implementation should call security_inode_listsecurity(),
# but this function is not exported for modules.

[group]
operation.name = removexattr
operation.returnType = int

operation.arg.type = struct dentry *
operation.arg.name = dentry

operation.arg.type = const char *
operation.arg.name = name

operation.object = dentry->d_inode

# Called by vfs_removexattr
operation.default = return -EOPNOTSUPP;

[group]
operation.name = fiemap
operation.returnType = int

operation.arg.type = struct inode *
operation.arg.name = inode

operation.arg.type = struct fiemap_extent_info*
operation.arg.name = fieinfo

operation.arg.type = u64
operation.arg.name = start

operation.arg.type = u64
operation.arg.name = len

operation.object = inode

# Called by ioctl_fiemap
operation.default = return -EOPNOTSUPP;
